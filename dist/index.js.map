{"version":3,"sources":["../src/providers/google.ts","../src/index.ts","../src/endpoints/getMissingAlt.ts","../src/endpoints/generateAlt.ts","../src/endpoints/saveAlt.ts","../src/endpoints/saveBulkAlt.ts","../src/providers/anthropic.ts","../src/providers/openai.ts","../src/providers/index.ts","../src/plugin.ts"],"sourcesContent":["import { generateText } from 'ai'\nimport { createGoogleGenerativeAI } from '@ai-sdk/google'\nimport type { AIVisionProvider, GenerateAltTextParams } from './types'\n\nexport interface GoogleProviderOptions {\n  apiKey?: string\n  model?: string\n}\n\nconst DEFAULT_MODEL = 'gemini-1.5-flash'\n\nexport class GoogleProvider implements AIVisionProvider {\n  readonly name = 'google'\n  private apiKey?: string\n  private model: string\n\n  constructor(options: GoogleProviderOptions = {}) {\n    this.apiKey = options.apiKey\n    this.model = options.model ?? DEFAULT_MODEL\n  }\n\n  async generateAltText(params: GenerateAltTextParams): Promise<{ altText: string }> {\n    const { image, prompt, maxLength } = params\n\n    const google = createGoogleGenerativeAI({\n      apiKey: this.apiKey ?? process.env.GOOGLE_GENERATIVE_AI_API_KEY,\n    })\n\n    // Retry with exponential backoff for rate limits\n    let result\n    let retries = 0\n    const maxRetries = 3\n\n    while (retries <= maxRetries) {\n      try {\n        result = await generateText({\n          model: google(this.model),\n          maxOutputTokens: 100,\n          messages: [\n            {\n              role: 'user',\n              content: [\n                {\n                  type: 'image',\n                  image: `data:${image.mediaType};base64,${image.base64Data}`,\n                },\n                {\n                  type: 'text',\n                  text: prompt,\n                },\n              ],\n            },\n          ],\n        })\n        break\n      } catch (err) {\n        const isRateLimit = err instanceof Error && (\n          err.message.includes('429') ||\n          err.message.includes('RESOURCE_EXHAUSTED') ||\n          err.message.includes('rate limit')\n        )\n        if (isRateLimit && retries < maxRetries) {\n          const delay = Math.pow(2, retries) * 15000 // 15s, 30s, 60s\n          await new Promise(resolve => setTimeout(resolve, delay))\n          retries++\n        } else {\n          throw err\n        }\n      }\n    }\n\n    const altText = result!.text.trim().slice(0, maxLength)\n    return { altText }\n  }\n}\n","export { altTextGeneratorPlugin } from './plugin'\nexport type {\n  AltTextGeneratorPluginOptions,\n  ImageWithoutAlt,\n  AltTextSuggestion,\n  AIProvider,\n  ProviderConfig,\n  AnthropicProviderConfig,\n  OpenAIProviderConfig,\n  GoogleProviderConfig,\n} from './types'\n","import type { PayloadHandler } from 'payload'\nimport type { AltTextGeneratorPluginOptions } from '../types'\n\nconst IMAGE_EXTENSIONS = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'avif', 'bmp', 'tiff', 'tif', 'svg']\n\nfunction isImageFile(filename: string): boolean {\n  const ext = filename.split('.').pop()?.toLowerCase() || ''\n  return IMAGE_EXTENSIONS.includes(ext)\n}\n\nexport const getMissingAlt = (\n  options: Required<AltTextGeneratorPluginOptions>\n): PayloadHandler => {\n  return async (req) => {\n    const { payload, user } = req\n\n    if (!user) {\n      return Response.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const collectionSlug =\n      (req.routeParams?.collection as string) || options.collections[0]\n\n    // Check if we only need the count (for badge display)\n    const countOnly = req.searchParams?.get('countOnly') === 'true'\n\n    try {\n      const whereClause = {\n        or: [\n          { [options.altFieldName]: { equals: '' } },\n          { [options.altFieldName]: { equals: null } },\n          { [options.altFieldName]: { exists: false } },\n        ],\n      }\n\n      if (countOnly) {\n        // Fetch filenames to filter by image type\n        const files = await payload.find({\n          collection: collectionSlug,\n          where: whereClause,\n          limit: 500,\n          depth: 0,\n          select: { filename: true },\n        })\n        const imageCount = files.docs.filter((doc: Record<string, unknown>) => {\n          const filename = doc.filename as string\n          return filename && isImageFile(filename)\n        }).length\n        return Response.json({ totalDocs: imageCount })\n      }\n\n      const images = await payload.find({\n        collection: collectionSlug,\n        where: whereClause,\n        limit: 500,\n        depth: 0,\n        select: {\n          id: true,\n          filename: true,\n          url: true,\n          [options.altFieldName]: true,\n        },\n      })\n\n      // Filter to only include image files\n      const imageDocs = images.docs\n        .filter((img: Record<string, unknown>) => {\n          const filename = img.filename as string\n          return filename && isImageFile(filename)\n        })\n        .map((img: Record<string, unknown>) => ({\n          id: img.id,\n          filename: img.filename,\n          url: img.url,\n          alt: (img[options.altFieldName] as string) || null,\n        }))\n\n      return Response.json({\n        docs: imageDocs,\n        totalDocs: imageDocs.length,\n      })\n    } catch (error) {\n      console.error('[alt-text-generator] Error fetching images:', error)\n      return Response.json({ error: 'Failed to fetch images' }, { status: 500 })\n    }\n  }\n}\n","import type { PayloadHandler } from 'payload'\nimport type { AltTextGeneratorPluginOptions } from '../types'\nimport type { AIVisionProvider } from '../providers/types'\nimport sharp from 'sharp'\n\n/**\n * Derive alt text from filename for SVGs and other unsupported formats\n */\nfunction deriveAltFromFilename(filename: string): string {\n  // Remove path if present\n  const basename = filename.split('/').pop() || filename\n\n  // Remove extension\n  const nameWithoutExt = basename.replace(/\\.[^.]+$/, '')\n\n  // Replace hyphens, underscores, and camelCase with spaces\n  const spaced = nameWithoutExt\n    .replace(/[-_]/g, ' ')\n    .replace(/([a-z])([A-Z])/g, '$1 $2')\n    .toLowerCase()\n\n  // Clean up multiple spaces and trim\n  const cleaned = spaced.replace(/\\s+/g, ' ').trim()\n\n  // Detect if it's likely an icon or logo\n  const isIcon = /icon|ico$/i.test(nameWithoutExt)\n  const isLogo = /logo/i.test(nameWithoutExt)\n\n  if (isIcon && !cleaned.includes('icon')) {\n    return `${cleaned} icon`\n  }\n  if (isLogo && !cleaned.includes('logo')) {\n    return `${cleaned} logo`\n  }\n\n  return cleaned\n}\n\nexport interface GenerateAltOptions extends Required<AltTextGeneratorPluginOptions> {\n  aiProvider: AIVisionProvider\n}\n\nexport const generateAlt = (\n  options: GenerateAltOptions\n): PayloadHandler => {\n  const { aiProvider } = options\n\n  return async (req) => {\n    const { user } = req\n\n    if (!user) {\n      return Response.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = (await req.json()) as {\n      imageId?: string\n      imageUrl?: string\n      filename?: string\n    }\n    const { imageId, imageUrl, filename } = body\n\n    if (!imageUrl) {\n      return Response.json({ error: 'Image URL is required' }, { status: 400 })\n    }\n\n    try {\n      // Check file extension\n      const urlPath = imageUrl.split('?')[0].toLowerCase()\n      const filenameLower = (filename || '').toLowerCase()\n      const ext = filenameLower.split('.').pop() || urlPath.split('.').pop() || ''\n\n      // Supported image formats\n      const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'avif', 'bmp', 'tiff', 'tif', 'svg']\n      const isImage = imageExtensions.includes(ext)\n\n      if (!isImage) {\n        return Response.json({\n          error: 'Not an image',\n          details: `File type \".${ext}\" is not supported. Only images can have alt text generated.`,\n        }, { status: 400 })\n      }\n\n      // SVGs: derive alt from filename instead of using Vision API\n      const isSvg = ext === 'svg'\n\n      if (isSvg) {\n        const suggestedAlt = deriveAltFromFilename(filename || imageUrl)\n        return Response.json({\n          id: imageId,\n          filename,\n          suggestedAlt,\n          imageUrl,\n        })\n      }\n\n      // Build full URL if relative\n      let fullImageUrl = imageUrl\n      if (imageUrl.startsWith('/')) {\n        const protocol = req.headers.get('x-forwarded-proto') || 'http'\n        const host = req.headers.get('host') || 'localhost:3000'\n        fullImageUrl = `${protocol}://${host}${imageUrl}`\n      }\n\n      // Fetch and convert image to base64\n      const imageResponse = await fetch(fullImageUrl)\n\n      if (!imageResponse.ok) {\n        throw new Error(`Failed to fetch image: ${imageResponse.status}`)\n      }\n\n      let imageBuffer = Buffer.from(await imageResponse.arrayBuffer())\n      let wasResized = false\n\n      // Check image dimensions and file size\n      const metadata = await sharp(imageBuffer).metadata()\n      const MAX_SIZE = 4 * 1024 * 1024 // 4MB to leave headroom\n      const MAX_DIMENSION = 7500 // Claude limit is 8000, leave some headroom\n\n      const needsResize =\n        imageBuffer.byteLength > MAX_SIZE ||\n        (metadata.width && metadata.width > MAX_DIMENSION) ||\n        (metadata.height && metadata.height > MAX_DIMENSION)\n\n      if (needsResize) {\n        imageBuffer = await sharp(imageBuffer)\n          .resize(1600, 1600, { fit: 'inside', withoutEnlargement: true })\n          .jpeg({ quality: 80 })\n          .toBuffer()\n        wasResized = true\n      }\n\n      const base64Data = imageBuffer.toString('base64')\n\n      // Determine media type (jpeg if we resized, otherwise from content-type)\n      const contentType = imageResponse.headers.get('content-type') || ''\n      let mediaType: 'image/jpeg' | 'image/png' | 'image/gif' | 'image/webp' = 'image/jpeg'\n\n      if (!wasResized) {\n        if (contentType.includes('png')) mediaType = 'image/png'\n        else if (contentType.includes('webp')) mediaType = 'image/webp'\n        else if (contentType.includes('gif')) mediaType = 'image/gif'\n      }\n\n      // Build prompt with replacements\n      let prompt = options.prompt\n        .replace(/{filename}/g, filename || 'unknown')\n        .replace(/{maxLength}/g, String(options.maxLength))\n        .replace(/{language}/g, options.language)\n\n      // Append extended prompt if provided\n      if (options.extendPrompt) {\n        const extendedPart = options.extendPrompt\n          .replace(/{filename}/g, filename || 'unknown')\n          .replace(/{maxLength}/g, String(options.maxLength))\n          .replace(/{language}/g, options.language)\n        prompt = `${prompt}\\n\\n${extendedPart}`\n      }\n\n      // Call the AI provider\n      const result = await aiProvider.generateAltText({\n        image: { base64Data, mediaType },\n        prompt,\n        maxLength: options.maxLength,\n      })\n\n      return Response.json({\n        id: imageId,\n        filename,\n        suggestedAlt: result.altText,\n        imageUrl,\n      })\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error)\n      console.error('[alt-text-generator] Error generating alt text:', errorMessage)\n      return Response.json(\n        { error: 'Failed to generate alt text', details: errorMessage },\n        { status: 500 }\n      )\n    }\n  }\n}\n","import type { PayloadHandler } from 'payload'\nimport type { AltTextGeneratorPluginOptions } from '../types'\n\nexport const saveAlt = (\n  options: Required<AltTextGeneratorPluginOptions>\n): PayloadHandler => {\n  return async (req) => {\n    const { payload, user } = req\n\n    if (!user) {\n      return Response.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = (await req.json()) as {\n      imageId?: string\n      altText?: string\n      collectionSlug?: string\n    }\n    const { imageId, altText, collectionSlug } = body\n\n    if (!imageId || altText === undefined) {\n      return Response.json(\n        { error: 'Image ID and alt text are required' },\n        { status: 400 }\n      )\n    }\n\n    const collection = collectionSlug || options.collections[0]\n\n    try {\n      await payload.update({\n        collection,\n        id: imageId,\n        data: {\n          [options.altFieldName]: altText,\n        },\n      })\n\n      return Response.json({ success: true, id: imageId })\n    } catch (error) {\n      console.error('[alt-text-generator] Error saving alt text:', error)\n      return Response.json({ error: 'Failed to save alt text' }, { status: 500 })\n    }\n  }\n}\n","import type { PayloadHandler } from 'payload'\nimport type { AltTextGeneratorPluginOptions } from '../types'\n\nexport const saveBulkAlt = (\n  options: Required<AltTextGeneratorPluginOptions>\n): PayloadHandler => {\n  return async (req) => {\n    const { payload, user } = req\n\n    if (!user) {\n      return Response.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = (await req.json()) as {\n      updates?: Array<{ id: string; alt: string }>\n      collectionSlug?: string\n    }\n    const { updates, collectionSlug } = body\n\n    if (!updates || !Array.isArray(updates)) {\n      return Response.json(\n        { error: 'Updates array is required' },\n        { status: 400 }\n      )\n    }\n\n    const collection = collectionSlug || options.collections[0]\n    const results = { success: [] as string[], failed: [] as string[] }\n\n    // Process updates in parallel for better performance\n    const updatePromises = updates.map(async (update) => {\n      try {\n        await payload.update({\n          collection,\n          id: update.id,\n          data: {\n            [options.altFieldName]: update.alt,\n          },\n        })\n        return { id: update.id, success: true }\n      } catch (error) {\n        console.error(\n          `[alt-text-generator] Failed to update ${update.id}:`,\n          error\n        )\n        return { id: update.id, success: false }\n      }\n    })\n\n    const settled = await Promise.all(updatePromises)\n\n    for (const result of settled) {\n      if (result.success) {\n        results.success.push(result.id)\n      } else {\n        results.failed.push(result.id)\n      }\n    }\n\n    return Response.json(results)\n  }\n}\n","import { generateText } from 'ai'\nimport { createAnthropic } from '@ai-sdk/anthropic'\nimport type { AIVisionProvider, GenerateAltTextParams } from './types'\n\nexport interface AnthropicProviderOptions {\n  apiKey?: string\n  model?: string\n}\n\nconst DEFAULT_MODEL = 'claude-sonnet-4-20250514'\n\nexport class AnthropicProvider implements AIVisionProvider {\n  readonly name = 'anthropic'\n  private apiKey?: string\n  private model: string\n\n  constructor(options: AnthropicProviderOptions = {}) {\n    this.apiKey = options.apiKey\n    this.model = options.model ?? DEFAULT_MODEL\n  }\n\n  async generateAltText(params: GenerateAltTextParams): Promise<{ altText: string }> {\n    const { image, prompt, maxLength } = params\n\n    const anthropic = createAnthropic({\n      apiKey: this.apiKey ?? process.env.ANTHROPIC_API_KEY,\n    })\n\n    // Retry with exponential backoff for rate limits\n    let result\n    let retries = 0\n    const maxRetries = 3\n\n    while (retries <= maxRetries) {\n      try {\n        result = await generateText({\n          model: anthropic(this.model),\n          maxOutputTokens: 100,\n          messages: [\n            {\n              role: 'user',\n              content: [\n                {\n                  type: 'image',\n                  image: `data:${image.mediaType};base64,${image.base64Data}`,\n                },\n                {\n                  type: 'text',\n                  text: prompt,\n                },\n              ],\n            },\n          ],\n        })\n        break\n      } catch (err) {\n        const isRateLimit = err instanceof Error && (\n          err.message.includes('429') ||\n          err.message.includes('rate limit')\n        )\n        if (isRateLimit && retries < maxRetries) {\n          const delay = Math.pow(2, retries) * 15000 // 15s, 30s, 60s\n          await new Promise(resolve => setTimeout(resolve, delay))\n          retries++\n        } else {\n          throw err\n        }\n      }\n    }\n\n    const altText = result!.text.trim().slice(0, maxLength)\n    return { altText }\n  }\n}\n","import { generateText } from 'ai'\nimport { createOpenAI } from '@ai-sdk/openai'\nimport type { AIVisionProvider, GenerateAltTextParams } from './types'\n\nexport interface OpenAIProviderOptions {\n  apiKey?: string\n  model?: string\n}\n\nconst DEFAULT_MODEL = 'gpt-4o'\n\nexport class OpenAIProvider implements AIVisionProvider {\n  readonly name = 'openai'\n  private apiKey?: string\n  private model: string\n\n  constructor(options: OpenAIProviderOptions = {}) {\n    this.apiKey = options.apiKey\n    this.model = options.model ?? DEFAULT_MODEL\n  }\n\n  async generateAltText(params: GenerateAltTextParams): Promise<{ altText: string }> {\n    const { image, prompt, maxLength } = params\n\n    const openai = createOpenAI({\n      apiKey: this.apiKey ?? process.env.OPENAI_API_KEY,\n    })\n\n    // Retry with exponential backoff for rate limits\n    let result\n    let retries = 0\n    const maxRetries = 3\n\n    while (retries <= maxRetries) {\n      try {\n        result = await generateText({\n          model: openai(this.model),\n          maxOutputTokens: 100,\n          messages: [\n            {\n              role: 'user',\n              content: [\n                {\n                  type: 'image',\n                  image: `data:${image.mediaType};base64,${image.base64Data}`,\n                },\n                {\n                  type: 'text',\n                  text: prompt,\n                },\n              ],\n            },\n          ],\n        })\n        break\n      } catch (err) {\n        const isRateLimit = err instanceof Error && (\n          err.message.includes('429') ||\n          err.message.includes('rate limit')\n        )\n        if (isRateLimit && retries < maxRetries) {\n          const delay = Math.pow(2, retries) * 15000 // 15s, 30s, 60s\n          await new Promise(resolve => setTimeout(resolve, delay))\n          retries++\n        } else {\n          throw err\n        }\n      }\n    }\n\n    const altText = result!.text.trim().slice(0, maxLength)\n    return { altText }\n  }\n}\n","import type { ProviderConfig } from '../types'\nimport type { AIVisionProvider } from './types'\nimport { AnthropicProvider } from './anthropic'\nimport { OpenAIProvider } from './openai'\n\nexport type { AIVisionProvider, ImageInput, GenerateAltTextParams } from './types'\n\nexport function createProvider(config?: ProviderConfig): AIVisionProvider {\n  if (!config) {\n    return new OpenAIProvider()\n  }\n\n  switch (config.provider) {\n    case 'anthropic':\n      return new AnthropicProvider({\n        apiKey: config.apiKey,\n        model: config.model,\n      })\n\n    case 'openai':\n      return new OpenAIProvider({\n        apiKey: config.apiKey,\n        model: config.model,\n      })\n\n    case 'google': {\n      // Lazy load Google provider to avoid requiring @ai-sdk/google when not used\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\n      const { GoogleProvider } = require('./google')\n      return new GoogleProvider({\n        apiKey: config.apiKey,\n        model: config.model,\n      })\n    }\n\n    default: {\n      const exhaustiveCheck: never = config\n      throw new Error(`Unknown provider: ${(exhaustiveCheck as ProviderConfig).provider}`)\n    }\n  }\n}\n","import type { Config, Plugin } from 'payload'\nimport type { AltTextGeneratorPluginOptions, ProviderConfig } from './types'\nimport { getMissingAlt } from './endpoints/getMissingAlt'\nimport { generateAlt } from './endpoints/generateAlt'\nimport { saveAlt } from './endpoints/saveAlt'\nimport { saveBulkAlt } from './endpoints/saveBulkAlt'\nimport { createProvider } from './providers'\n\ninterface InternalOptions extends Required<AltTextGeneratorPluginOptions> {\n  provider: ProviderConfig\n}\n\nconst defaultOptions: InternalOptions = {\n  collections: ['media'],\n  prompt: `Generate a short alt text for this image IN {language}. The filename is \"{filename}\".\n\nRules:\n- Write in {language}\n- Keep it short: aim for 5-10 words, max {maxLength} characters\n- For logos: just use the company/brand name followed by \"logo\" (e.g. \"Rivas Zorggroep logo\")\n- For icons or decorative images: say \"decorative\"\n- For photos: briefly describe the key subject\n- Don't start with \"Image of\", \"Photo of\", \"Picture of\" or translations thereof\n- The filename often contains the subject â€” use it as a strong hint\n\nRespond with ONLY the alt text, nothing else.`,\n  extendPrompt: '',\n  maxLength: 80,\n  batchSize: 5,\n  model: 'gpt-4o-mini',\n  altFieldName: 'alt',\n  language: 'English',\n  provider: { provider: 'openai' },\n}\n\n/**\n * Resolve provider configuration with backwards compatibility\n */\nfunction resolveProviderConfig(pluginOptions: AltTextGeneratorPluginOptions): ProviderConfig {\n  // If explicit provider config is provided, use it\n  if (pluginOptions.provider) {\n    return pluginOptions.provider\n  }\n\n  // Backwards compatibility: if only model is specified, detect provider from model name\n  if (pluginOptions.model) {\n    console.warn(\n      '[alt-text-generator] The \"model\" option is deprecated. Use \"provider: { provider: \\'...\\', model: \\'...\\' }\" instead.'\n    )\n    // Detect provider from model name\n    if (pluginOptions.model.startsWith('claude')) {\n      return { provider: 'anthropic', model: pluginOptions.model }\n    } else if (pluginOptions.model.startsWith('gemini')) {\n      return { provider: 'google', model: pluginOptions.model }\n    }\n    return { provider: 'openai', model: pluginOptions.model }\n  }\n\n  // Default to OpenAI (most cost-effective)\n  return { provider: 'openai' }\n}\n\nexport const altTextGeneratorPlugin = (\n  pluginOptions: AltTextGeneratorPluginOptions = {}\n): Plugin => {\n  const providerConfig = resolveProviderConfig(pluginOptions)\n  const options: InternalOptions = {\n    ...defaultOptions,\n    ...pluginOptions,\n    provider: providerConfig,\n  }\n\n  // Create the AI provider instance\n  const aiProvider = createProvider(providerConfig)\n\n  return (incomingConfig: Config): Config => {\n    // Find and modify the specified collections\n    const collections = (incomingConfig.collections || []).map((collection) => {\n      if (!options.collections.includes(collection.slug)) {\n        return collection\n      }\n\n      // Add GenerateAltButton as afterInput on the alt field\n      const fields = (collection.fields || []).map((field) => {\n        if (!('name' in field) || field.name !== options.altFieldName) {\n          return field\n        }\n\n        const existingAdmin = 'admin' in field ? (field.admin || {}) : {}\n        const existingComponents = ('components' in existingAdmin ? existingAdmin.components : {}) || {}\n        const existingAfterInput = ('afterInput' in existingComponents && Array.isArray(existingComponents.afterInput))\n          ? existingComponents.afterInput\n          : []\n\n        return {\n          ...field,\n          admin: {\n            ...existingAdmin,\n            components: {\n              ...existingComponents,\n              afterInput: [\n                ...existingAfterInput,\n                {\n                  path: '@diffusenl/payload-alt-text-generator/components#GenerateAltButton',\n                  clientProps: {\n                    collectionSlug: collection.slug,\n                    altFieldName: options.altFieldName,\n                  },\n                },\n              ],\n            },\n          },\n        } as typeof field\n      })\n\n      return {\n        ...collection,\n        fields,\n        endpoints: [\n          ...(collection.endpoints || []),\n          {\n            path: '/missing-alt',\n            method: 'get' as const,\n            handler: getMissingAlt(options),\n          },\n          {\n            path: '/generate-alt',\n            method: 'post' as const,\n            handler: generateAlt({ ...options, aiProvider }),\n          },\n          {\n            path: '/save-alt',\n            method: 'post' as const,\n            handler: saveAlt(options),\n          },\n          {\n            path: '/save-bulk-alt',\n            method: 'post' as const,\n            handler: saveBulkAlt(options),\n          },\n        ],\n        admin: {\n          ...collection.admin,\n          components: {\n            ...collection.admin?.components,\n            beforeListTable: [\n              ...(collection.admin?.components?.beforeListTable || []),\n              {\n                path: '@diffusenl/payload-alt-text-generator/components#AltTextGenerator',\n                clientProps: {\n                  collectionSlug: collection.slug,\n                  options: {\n                    batchSize: options.batchSize,\n                    altFieldName: options.altFieldName,\n                  },\n                },\n              },\n            ],\n          },\n        },\n      }\n    })\n\n    return {\n      ...incomingConfig,\n      collections,\n    }\n  }\n}\n"],"mappings":"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","names":["import_ai","DEFAULT_MODEL","sharp","import_ai","DEFAULT_MODEL","GoogleProvider"]}