{"version":3,"sources":["../src/index.ts","../src/endpoints/getMissingAlt.ts","../src/endpoints/generateAlt.ts","../src/endpoints/saveAlt.ts","../src/endpoints/saveBulkAlt.ts","../src/plugin.ts"],"sourcesContent":["export { altTextGeneratorPlugin } from './plugin'\nexport type {\n  AltTextGeneratorPluginOptions,\n  ImageWithoutAlt,\n  AltTextSuggestion,\n} from './types'\n","import type { PayloadHandler } from 'payload'\nimport type { AltTextGeneratorPluginOptions } from '../types'\n\nconst IMAGE_EXTENSIONS = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'avif', 'bmp', 'tiff', 'tif', 'svg']\n\nfunction isImageFile(filename: string): boolean {\n  const ext = filename.split('.').pop()?.toLowerCase() || ''\n  return IMAGE_EXTENSIONS.includes(ext)\n}\n\nexport const getMissingAlt = (\n  options: Required<AltTextGeneratorPluginOptions>\n): PayloadHandler => {\n  return async (req) => {\n    const { payload, user } = req\n\n    if (!user) {\n      return Response.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const collectionSlug =\n      (req.routeParams?.collection as string) || options.collections[0]\n\n    // Check if we only need the count (for badge display)\n    const countOnly = req.searchParams?.get('countOnly') === 'true'\n\n    try {\n      const whereClause = {\n        or: [\n          { [options.altFieldName]: { equals: '' } },\n          { [options.altFieldName]: { equals: null } },\n          { [options.altFieldName]: { exists: false } },\n        ],\n      }\n\n      if (countOnly) {\n        // Fetch filenames to filter by image type\n        const files = await payload.find({\n          collection: collectionSlug,\n          where: whereClause,\n          limit: 500,\n          depth: 0,\n          select: { filename: true },\n        })\n        const imageCount = files.docs.filter((doc: Record<string, unknown>) => {\n          const filename = doc.filename as string\n          return filename && isImageFile(filename)\n        }).length\n        return Response.json({ totalDocs: imageCount })\n      }\n\n      const images = await payload.find({\n        collection: collectionSlug,\n        where: whereClause,\n        limit: 500,\n        depth: 0,\n        select: {\n          id: true,\n          filename: true,\n          url: true,\n          [options.altFieldName]: true,\n        },\n      })\n\n      // Filter to only include image files\n      const imageDocs = images.docs\n        .filter((img: Record<string, unknown>) => {\n          const filename = img.filename as string\n          return filename && isImageFile(filename)\n        })\n        .map((img: Record<string, unknown>) => ({\n          id: img.id,\n          filename: img.filename,\n          url: img.url,\n          alt: (img[options.altFieldName] as string) || null,\n        }))\n\n      return Response.json({\n        docs: imageDocs,\n        totalDocs: imageDocs.length,\n      })\n    } catch (error) {\n      console.error('[alt-text-generator] Error fetching images:', error)\n      return Response.json({ error: 'Failed to fetch images' }, { status: 500 })\n    }\n  }\n}\n","import type { PayloadHandler } from 'payload'\nimport type { AltTextGeneratorPluginOptions } from '../types'\nimport Anthropic from '@anthropic-ai/sdk'\nimport sharp from 'sharp'\n\n/**\n * Derive alt text from filename for SVGs and other unsupported formats\n */\nfunction deriveAltFromFilename(filename: string): string {\n  // Remove path if present\n  const basename = filename.split('/').pop() || filename\n\n  // Remove extension\n  const nameWithoutExt = basename.replace(/\\.[^.]+$/, '')\n\n  // Replace hyphens, underscores, and camelCase with spaces\n  const spaced = nameWithoutExt\n    .replace(/[-_]/g, ' ')\n    .replace(/([a-z])([A-Z])/g, '$1 $2')\n    .toLowerCase()\n\n  // Clean up multiple spaces and trim\n  const cleaned = spaced.replace(/\\s+/g, ' ').trim()\n\n  // Detect if it's likely an icon or logo\n  const isIcon = /icon|ico$/i.test(nameWithoutExt)\n  const isLogo = /logo/i.test(nameWithoutExt)\n\n  if (isIcon && !cleaned.includes('icon')) {\n    return `${cleaned} icon`\n  }\n  if (isLogo && !cleaned.includes('logo')) {\n    return `${cleaned} logo`\n  }\n\n  return cleaned\n}\n\nexport const generateAlt = (\n  options: Required<AltTextGeneratorPluginOptions>\n): PayloadHandler => {\n  return async (req) => {\n    const { user } = req\n\n    if (!user) {\n      return Response.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = (await req.json()) as {\n      imageId?: string\n      imageUrl?: string\n      filename?: string\n    }\n    const { imageId, imageUrl, filename } = body\n\n    if (!imageUrl) {\n      return Response.json({ error: 'Image URL is required' }, { status: 400 })\n    }\n\n    try {\n      // Check file extension\n      const urlPath = imageUrl.split('?')[0].toLowerCase()\n      const filenameLower = (filename || '').toLowerCase()\n      const ext = filenameLower.split('.').pop() || urlPath.split('.').pop() || ''\n\n      // Supported image formats\n      const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'avif', 'bmp', 'tiff', 'tif', 'svg']\n      const isImage = imageExtensions.includes(ext)\n\n      if (!isImage) {\n        return Response.json({\n          error: 'Not an image',\n          details: `File type \".${ext}\" is not supported. Only images can have alt text generated.`,\n        }, { status: 400 })\n      }\n\n      // SVGs: derive alt from filename instead of using Vision API\n      const isSvg = ext === 'svg'\n\n      if (isSvg) {\n        const suggestedAlt = deriveAltFromFilename(filename || imageUrl)\n        return Response.json({\n          id: imageId,\n          filename,\n          suggestedAlt,\n          imageUrl,\n        })\n      }\n\n      const anthropic = new Anthropic({\n        apiKey: process.env.ANTHROPIC_API_KEY,\n      })\n\n      // Build full URL if relative\n      let fullImageUrl = imageUrl\n      if (imageUrl.startsWith('/')) {\n        const protocol = req.headers.get('x-forwarded-proto') || 'http'\n        const host = req.headers.get('host') || 'localhost:3000'\n        fullImageUrl = `${protocol}://${host}${imageUrl}`\n      }\n\n      // Fetch and convert image to base64\n      const imageResponse = await fetch(fullImageUrl)\n\n      if (!imageResponse.ok) {\n        throw new Error(`Failed to fetch image: ${imageResponse.status}`)\n      }\n\n      let imageBuffer = Buffer.from(await imageResponse.arrayBuffer())\n      let wasResized = false\n\n      // Check image dimensions and file size\n      const metadata = await sharp(imageBuffer).metadata()\n      const MAX_SIZE = 4 * 1024 * 1024 // 4MB to leave headroom\n      const MAX_DIMENSION = 7500 // Claude limit is 8000, leave some headroom\n\n      const needsResize =\n        imageBuffer.byteLength > MAX_SIZE ||\n        (metadata.width && metadata.width > MAX_DIMENSION) ||\n        (metadata.height && metadata.height > MAX_DIMENSION)\n\n      if (needsResize) {\n        imageBuffer = await sharp(imageBuffer)\n          .resize(1600, 1600, { fit: 'inside', withoutEnlargement: true })\n          .jpeg({ quality: 80 })\n          .toBuffer()\n        wasResized = true\n      }\n\n      const base64Image = imageBuffer.toString('base64')\n\n      // Determine media type (jpeg if we resized, otherwise from content-type)\n      const contentType = imageResponse.headers.get('content-type') || ''\n      let mediaType: 'image/jpeg' | 'image/png' | 'image/gif' | 'image/webp' = 'image/jpeg'\n\n      if (!wasResized) {\n        if (contentType.includes('png')) mediaType = 'image/png'\n        else if (contentType.includes('webp')) mediaType = 'image/webp'\n        else if (contentType.includes('gif')) mediaType = 'image/gif'\n      }\n\n      // Build prompt with replacements\n      const prompt = options.prompt\n        .replace(/{filename}/g, filename || 'unknown')\n        .replace(/{maxLength}/g, String(options.maxLength))\n        .replace(/{language}/g, options.language)\n\n      // Retry with exponential backoff for rate limits\n      let message\n      let retries = 0\n      const maxRetries = 3\n\n      while (retries <= maxRetries) {\n        try {\n          message = await anthropic.messages.create({\n            model: options.model,\n            max_tokens: 100,\n            messages: [\n              {\n                role: 'user',\n                content: [\n                  {\n                    type: 'image',\n                    source: {\n                      type: 'base64',\n                      media_type: mediaType,\n                      data: base64Image,\n                    },\n                  },\n                  {\n                    type: 'text',\n                    text: prompt,\n                  },\n                ],\n              },\n            ],\n          })\n          break\n        } catch (err) {\n          const isRateLimit = err instanceof Error && err.message.includes('429')\n          if (isRateLimit && retries < maxRetries) {\n            const delay = Math.pow(2, retries) * 15000 // 15s, 30s, 60s\n            await new Promise(resolve => setTimeout(resolve, delay))\n            retries++\n          } else {\n            throw err\n          }\n        }\n      }\n\n      const suggestedAlt =\n        message.content[0].type === 'text'\n          ? message.content[0].text.trim().slice(0, options.maxLength)\n          : ''\n\n      return Response.json({\n        id: imageId,\n        filename,\n        suggestedAlt,\n        imageUrl,\n      })\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error)\n      console.error('[alt-text-generator] Error generating alt text:', errorMessage)\n      return Response.json(\n        { error: 'Failed to generate alt text', details: errorMessage },\n        { status: 500 }\n      )\n    }\n  }\n}\n","import type { PayloadHandler } from 'payload'\nimport type { AltTextGeneratorPluginOptions } from '../types'\n\nexport const saveAlt = (\n  options: Required<AltTextGeneratorPluginOptions>\n): PayloadHandler => {\n  return async (req) => {\n    const { payload, user } = req\n\n    if (!user) {\n      return Response.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = (await req.json()) as {\n      imageId?: string\n      altText?: string\n      collectionSlug?: string\n    }\n    const { imageId, altText, collectionSlug } = body\n\n    if (!imageId || altText === undefined) {\n      return Response.json(\n        { error: 'Image ID and alt text are required' },\n        { status: 400 }\n      )\n    }\n\n    const collection = collectionSlug || options.collections[0]\n\n    try {\n      await payload.update({\n        collection,\n        id: imageId,\n        data: {\n          [options.altFieldName]: altText,\n        },\n      })\n\n      return Response.json({ success: true, id: imageId })\n    } catch (error) {\n      console.error('[alt-text-generator] Error saving alt text:', error)\n      return Response.json({ error: 'Failed to save alt text' }, { status: 500 })\n    }\n  }\n}\n","import type { PayloadHandler } from 'payload'\nimport type { AltTextGeneratorPluginOptions } from '../types'\n\nexport const saveBulkAlt = (\n  options: Required<AltTextGeneratorPluginOptions>\n): PayloadHandler => {\n  return async (req) => {\n    const { payload, user } = req\n\n    if (!user) {\n      return Response.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = (await req.json()) as {\n      updates?: Array<{ id: string; alt: string }>\n      collectionSlug?: string\n    }\n    const { updates, collectionSlug } = body\n\n    if (!updates || !Array.isArray(updates)) {\n      return Response.json(\n        { error: 'Updates array is required' },\n        { status: 400 }\n      )\n    }\n\n    const collection = collectionSlug || options.collections[0]\n    const results = { success: [] as string[], failed: [] as string[] }\n\n    // Process updates in parallel for better performance\n    const updatePromises = updates.map(async (update) => {\n      try {\n        await payload.update({\n          collection,\n          id: update.id,\n          data: {\n            [options.altFieldName]: update.alt,\n          },\n        })\n        return { id: update.id, success: true }\n      } catch (error) {\n        console.error(\n          `[alt-text-generator] Failed to update ${update.id}:`,\n          error\n        )\n        return { id: update.id, success: false }\n      }\n    })\n\n    const settled = await Promise.all(updatePromises)\n\n    for (const result of settled) {\n      if (result.success) {\n        results.success.push(result.id)\n      } else {\n        results.failed.push(result.id)\n      }\n    }\n\n    return Response.json(results)\n  }\n}\n","import type { Config, Plugin } from 'payload'\nimport type { AltTextGeneratorPluginOptions } from './types'\nimport { getMissingAlt } from './endpoints/getMissingAlt'\nimport { generateAlt } from './endpoints/generateAlt'\nimport { saveAlt } from './endpoints/saveAlt'\nimport { saveBulkAlt } from './endpoints/saveBulkAlt'\n\nconst defaultOptions: Required<AltTextGeneratorPluginOptions> = {\n  collections: ['media'],\n  prompt: `Generate a short alt text for this image IN {language}. The filename is \"{filename}\".\n\nRules:\n- Write in {language}\n- Keep it short: aim for 5-10 words, max {maxLength} characters\n- For logos: just use the company/brand name followed by \"logo\" (e.g. \"Rivas Zorggroep logo\")\n- For icons or decorative images: say \"decorative\"\n- For photos: briefly describe the key subject\n- Don't start with \"Image of\", \"Photo of\", \"Picture of\" or translations thereof\n- The filename often contains the subject â€” use it as a strong hint\n\nRespond with ONLY the alt text, nothing else.`,\n  maxLength: 80,\n  batchSize: 5,\n  model: 'claude-sonnet-4-20250514',\n  altFieldName: 'alt',\n  language: 'English',\n}\n\nexport const altTextGeneratorPlugin = (\n  pluginOptions: AltTextGeneratorPluginOptions = {}\n): Plugin => {\n  const options = { ...defaultOptions, ...pluginOptions }\n\n  return (incomingConfig: Config): Config => {\n    // Find and modify the specified collections\n    const collections = (incomingConfig.collections || []).map((collection) => {\n      if (!options.collections.includes(collection.slug)) {\n        return collection\n      }\n\n      // Add GenerateAltButton as afterInput on the alt field\n      const fields = (collection.fields || []).map((field) => {\n        if (!('name' in field) || field.name !== options.altFieldName) {\n          return field\n        }\n\n        const existingAdmin = 'admin' in field ? (field.admin || {}) : {}\n        const existingComponents = ('components' in existingAdmin ? existingAdmin.components : {}) || {}\n        const existingAfterInput = ('afterInput' in existingComponents && Array.isArray(existingComponents.afterInput))\n          ? existingComponents.afterInput\n          : []\n\n        return {\n          ...field,\n          admin: {\n            ...existingAdmin,\n            components: {\n              ...existingComponents,\n              afterInput: [\n                ...existingAfterInput,\n                {\n                  path: '@diffusenl/payload-alt-text-generator/components#GenerateAltButton',\n                  clientProps: {\n                    collectionSlug: collection.slug,\n                    altFieldName: options.altFieldName,\n                  },\n                },\n              ],\n            },\n          },\n        } as typeof field\n      })\n\n      return {\n        ...collection,\n        fields,\n        endpoints: [\n          ...(collection.endpoints || []),\n          {\n            path: '/missing-alt',\n            method: 'get' as const,\n            handler: getMissingAlt(options),\n          },\n          {\n            path: '/generate-alt',\n            method: 'post' as const,\n            handler: generateAlt(options),\n          },\n          {\n            path: '/save-alt',\n            method: 'post' as const,\n            handler: saveAlt(options),\n          },\n          {\n            path: '/save-bulk-alt',\n            method: 'post' as const,\n            handler: saveBulkAlt(options),\n          },\n        ],\n        admin: {\n          ...collection.admin,\n          components: {\n            ...collection.admin?.components,\n            beforeListTable: [\n              ...(collection.admin?.components?.beforeListTable || []),\n              {\n                path: '@diffusenl/payload-alt-text-generator/components#AltTextGenerator',\n                clientProps: {\n                  collectionSlug: collection.slug,\n                  options: {\n                    batchSize: options.batchSize,\n                    altFieldName: options.altFieldName,\n                  },\n                },\n              },\n            ],\n          },\n        },\n      }\n    })\n\n    return {\n      ...incomingConfig,\n      collections,\n    }\n  }\n}\n"],"mappings":"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","names":["suggestedAlt","Anthropic","sharp"]}